import {
    Component,
    Input,
    OnInit,
    OnDestroy,
    ChangeDetectorRef, Output, EventEmitter,
} from '@angular/core';
import { Subscription , timer} from "rxjs";

import { clone, DEFAULT_SUPPORTED_MIME_TYPE, VULNERABILITY_SCAN_STATUS } from '../../utils/utils';
import {
    VulnerabilitySummary,
    TagService,
    ScanningResultService,
    ScannerVo, ArtifactService
} from '../../services';
import { ErrorHandler } from '../../utils/error-handler';
import { JobLogService } from "../../services";
import { finalize } from "rxjs/operators";
import { ChannelService } from "../../services/channel.service";
import { Artifact } from '../artifact/artifact';

const STATE_CHECK_INTERVAL: number = 3000; // 3s
const RETRY_TIMES: number = 3;

@Component({
    selector: 'hbr-vulnerability-bar',
    templateUrl: './result-bar-chart-component.html',
    styleUrls: ['./scanning.scss']
})
export class ResultBarChartComponent implements OnInit, OnDestroy {
    @Input() scanner: ScannerVo;
    @Input() repoName: string = "";
    @Input() projectName: string = "";
    @Input() artifactId: string = "";
    @Input() summary: VulnerabilitySummary;
    onSubmitting: boolean = false;
    retryCounter: number = 0;
    stateCheckTimer: Subscription;
    scanSubscription: Subscription;
    timerHandler: any;
    
    @Output()
    submitFinish: EventEmitter<boolean> = new EventEmitter<boolean>();

    constructor(
        private tagService: TagService,
        private artifactService: ArtifactService,
        private scanningService: ScanningResultService,
        private errorHandler: ErrorHandler,
        private channel: ChannelService,
        private ref: ChangeDetectorRef,
        private jobLogService: JobLogService,
    ) { }

    ngOnInit(): void {

        if ((this.status === VULNERABILITY_SCAN_STATUS.RUNNING ||
            this.status === VULNERABILITY_SCAN_STATUS.PENDING) &&
            !this.stateCheckTimer) {
            // Avoid duplicated subscribing
            this.stateCheckTimer = timer(0, STATE_CHECK_INTERVAL).subscribe(() => {
                this.getSummary();
            });
        }
        this.scanSubscription = this.channel.scanCommand$.subscribe((artifactId: string) => {
            let myFullTag: string = this.repoName + "/" + this.artifactId;
            if (myFullTag === artifactId) {
                this.scanNow();
            }
        });
    }

    ngOnDestroy(): void {
        if (this.stateCheckTimer) {
            this.stateCheckTimer.unsubscribe();
            this.stateCheckTimer = null;
        }
        if (this.scanSubscription) {
            this.scanSubscription.unsubscribe();
        }
    }

    // Get vulnerability scanning status
    public get status(): string {
        if (this.summary && this.summary.scan_status) {
            return this.summary.scan_status;
        }
        return VULNERABILITY_SCAN_STATUS.NOT_SCANNED;
    }

    public get completed(): boolean {
        return this.status === VULNERABILITY_SCAN_STATUS.SUCCESS;
    }

    public get error(): boolean {
        return this.status === VULNERABILITY_SCAN_STATUS.ERROR;
    }

    public get queued(): boolean {
        return this.status === VULNERABILITY_SCAN_STATUS.PENDING;
    }

    public get scanning(): boolean {
        return this.status === VULNERABILITY_SCAN_STATUS.RUNNING;
    }
    public get otherStatus(): boolean {
        return !(this.completed || this.error || this.queued || this.scanning);
    }

    scanNow(): void {
        if (this.onSubmitting) {
            // Avoid duplicated submitting
            console.log("duplicated submit");
            return;
        }

        if (!this.repoName || !this.artifactId) {
            console.log("bad repository or tag");
            return;
        }

        this.onSubmitting = true;

        this.scanningService.startVulnerabilityScanning(this.projectName, this.repoName, this.artifactId)
            .pipe(finalize(() => this.submitFinish.emit(false)))
            .subscribe(() => {
                this.onSubmitting = false;

                // Forcely change status to queued after successful submitting
                this.summary = {
                    scan_status: VULNERABILITY_SCAN_STATUS.PENDING,
                };

                // Forcely refresh view
                this.forceRefreshView(1000);

                // Start check status util the job is done
                if (!this.stateCheckTimer) {
                    // Avoid duplicated subscribing
                    this.stateCheckTimer = timer(STATE_CHECK_INTERVAL, STATE_CHECK_INTERVAL).subscribe(() => {
                        this.getSummary();
                    });
                }
            }, error => {
                this.onSubmitting = false;
                if (error && error.error && error.error.code === 409) {
                     console.log(error.error.message);
                } else {
                     this.errorHandler.error(error);
                }
            });
    }

    getSummary(): void {
        if (!this.repoName || !this.artifactId) {
            return;
        }

        // this.tagService.getTag(this.repoName, this.artifactId)
        this.artifactService.getArtifactFromId(this.projectName, this.repoName, this.artifactId)
            .subscribe((artifact: Artifact) => {
                // To keep the same summary reference, use value copy.
                if (artifact.scan_overview) {
                    this.copyValue(artifact.scan_overview[DEFAULT_SUPPORTED_MIME_TYPE]);
                }
                // Forcely refresh view
                this.forceRefreshView(1000);

                if (!this.queued && !this.scanning) {
                    // Scanning should be done
                    if (this.stateCheckTimer) {
                        this.stateCheckTimer.unsubscribe();
                        this.stateCheckTimer = null;
                    }
                }
                this.channel.tagDetail$.next(artifact);
            }, error => {
                this.errorHandler.error(error);
                this.retryCounter++;
                if (this.retryCounter >= RETRY_TIMES) {
                    // Stop timer
                    if (this.stateCheckTimer) {
                        this.stateCheckTimer.unsubscribe();
                        this.stateCheckTimer = null;
                    }
                    this.retryCounter = 0;
                }
            });
    }

    copyValue(newVal: VulnerabilitySummary): void {
        if (!this.summary || !newVal || !newVal.scan_status) { return; }
        this.summary = clone(newVal);
    }

    forceRefreshView(duration: number): void {
        // Reset timer
        if (this.timerHandler) {
            clearInterval(this.timerHandler);
        }
        this.timerHandler = setInterval(() => this.ref.markForCheck(), 100);
        setTimeout(() => {
            if (this.timerHandler) {
                clearInterval(this.timerHandler);
                this.timerHandler = null;
            }
        }, duration);
    }
    viewLog(): string {
        return  `/api/v2.0/projects/${this.projectName}/repositories/${this.repoName}
        /artifacts/${this.artifactId}/scan/${this.summary.report_id}/log`;
    }
}
